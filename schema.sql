-- SMart Grocery Super Admin Schema (V7)
-- This script FIXES RLS "violate policy" errors for orders, wishlist, and addresses.
-- SAFE to run multiple times. Data stays intact.

-- 1. Table Consistency Check
CREATE TABLE IF NOT EXISTS public.profiles (
  id UUID REFERENCES auth.users(id) ON DELETE CASCADE PRIMARY KEY,
  email TEXT UNIQUE,
  full_name TEXT,
  role TEXT DEFAULT 'customer' CHECK (role IN ('admin', 'customer')),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

CREATE TABLE IF NOT EXISTS public.categories (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL,
  slug TEXT UNIQUE,
  image_url TEXT,
  parent_id BIGINT REFERENCES public.categories(id),
  item_count INT DEFAULT 0,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

CREATE TABLE IF NOT EXISTS public.products (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL,
  slug TEXT UNIQUE,
  price NUMERIC NOT NULL,
  original_price NUMERIC,
  category TEXT,
  brand TEXT,
  unit TEXT,
  sku TEXT,
  images TEXT[],
  image_url TEXT,
  short_description TEXT,
  description TEXT,
  badge TEXT,
  is_featured BOOLEAN DEFAULT false,
  variants JSONB DEFAULT '[]'::jsonb,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

CREATE TABLE IF NOT EXISTS public.orders (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  customer_name TEXT NOT NULL,
  customer_email TEXT,
  customer_phone TEXT,
  customer_address TEXT,
  customer_district TEXT,
  customer_area TEXT,
  subtotal NUMERIC DEFAULT 0,
  shipping_cost NUMERIC DEFAULT 0,
  discount NUMERIC DEFAULT 0,
  total NUMERIC DEFAULT 0,
  status TEXT DEFAULT 'Pending',
  items JSONB DEFAULT '[]'::jsonb,
  coupon_code TEXT,
  user_id UUID REFERENCES auth.users(id),
  date TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

CREATE TABLE IF NOT EXISTS public.settings (
  key TEXT PRIMARY KEY,
  value JSONB
);

-- 2. Storage Bucket Setup (Idempotent)
INSERT INTO storage.buckets (id, name, public) 
VALUES ('product-images', 'product-images', true)
ON CONFLICT (id) DO NOTHING;

-- 3. Storage Policies (Adjust for production security)
DROP POLICY IF EXISTS "Public Access" ON storage.objects;
CREATE POLICY "Public Access" ON storage.objects FOR SELECT USING ( bucket_id = 'product-images' );

DROP POLICY IF EXISTS "Auth Upload" ON storage.objects;
CREATE POLICY "Auth Upload" ON storage.objects FOR INSERT WITH CHECK ( bucket_id = 'product-images' AND auth.role() = 'authenticated' );


CREATE TABLE IF NOT EXISTS public.wishlist (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  product_id BIGINT REFERENCES public.products(id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  UNIQUE(user_id, product_id)
);

CREATE TABLE IF NOT EXISTS public.addresses (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  full_name TEXT,
  phone TEXT,
  address_line TEXT,
  district TEXT,
  area TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

CREATE TABLE IF NOT EXISTS public.pages (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  title TEXT NOT NULL,
  slug TEXT UNIQUE NOT NULL,
  content TEXT,
  is_published BOOLEAN DEFAULT true,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- 2. Reset RLS and Policies for clean application
DO $$ 
DECLARE 
  t text;
BEGIN
  FOR t IN (SELECT tablename FROM pg_tables WHERE schemaname = 'public') LOOP
    EXECUTE 'ALTER TABLE public.' || t || ' ENABLE ROW LEVEL SECURITY';
  END LOOP;
END $$;

DO $$ 
DECLARE 
  pol RECORD;
BEGIN
  FOR pol IN (SELECT policyname, tablename FROM pg_policies WHERE schemaname = 'public') LOOP
    EXECUTE 'DROP POLICY IF EXISTS "' || pol.policyname || '" ON public.' || pol.tablename;
  END LOOP;
END $$;

-- 3. APPLY BULLETPROOF ADMIN POLICIES
CREATE OR REPLACE FUNCTION public.get_my_role()
RETURNS text AS $$
  SELECT role FROM public.profiles WHERE id = auth.uid();
$$ LANGUAGE sql SECURITY DEFINER SET search_path = public;

CREATE POLICY "Admins manage products" ON public.products FOR ALL TO authenticated
USING ( public.get_my_role() = 'admin' OR (auth.jwt() ->> 'email') = 'msmraqeeb@gmail.com' )
WITH CHECK ( public.get_my_role() = 'admin' OR (auth.jwt() ->> 'email') = 'msmraqeeb@gmail.com' );
CREATE POLICY "Public read products" ON public.products FOR SELECT USING (true);

CREATE POLICY "Admins manage categories" ON public.categories FOR ALL TO authenticated
USING ( public.get_my_role() = 'admin' OR (auth.jwt() ->> 'email') = 'msmraqeeb@gmail.com' )
WITH CHECK ( public.get_my_role() = 'admin' OR (auth.jwt() ->> 'email') = 'msmraqeeb@gmail.com' );
CREATE POLICY "Public read categories" ON public.categories FOR SELECT USING (true);

CREATE POLICY "Admins manage orders" ON public.orders FOR ALL TO authenticated
USING ( public.get_my_role() = 'admin' OR (auth.jwt() ->> 'email') = 'msmraqeeb@gmail.com' )
WITH CHECK ( public.get_my_role() = 'admin' OR (auth.jwt() ->> 'email') = 'msmraqeeb@gmail.com' );
CREATE POLICY "Users can view own orders" ON public.orders FOR SELECT TO authenticated
USING ( auth.uid() = user_id );
CREATE POLICY "Anyone can insert orders" ON public.orders FOR INSERT WITH CHECK (true);

CREATE POLICY "Users manage own wishlist" ON public.wishlist FOR ALL USING (auth.uid() = user_id);
CREATE POLICY "Users manage own addresses" ON public.addresses FOR ALL USING (auth.uid() = user_id);

CREATE POLICY "Admins manage pages" ON public.pages FOR ALL TO authenticated
USING ( public.get_my_role() = 'admin' OR (auth.jwt() ->> 'email') = 'msmraqeeb@gmail.com' )
WITH CHECK ( public.get_my_role() = 'admin' OR (auth.jwt() ->> 'email') = 'msmraqeeb@gmail.com' );
CREATE POLICY "Public read pages" ON public.pages FOR SELECT USING (is_published = true);

CREATE TABLE IF NOT EXISTS public.brands (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL,
  slug TEXT UNIQUE,
  logo_url TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);
ALTER TABLE public.brands ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Admins manage brands" ON public.brands FOR ALL TO authenticated
USING ( public.get_my_role() = 'admin' OR (auth.jwt() ->> 'email') = 'msmraqeeb@gmail.com' )
WITH CHECK ( public.get_my_role() = 'admin' OR (auth.jwt() ->> 'email') = 'msmraqeeb@gmail.com' );
CREATE POLICY "Public read brands" ON public.brands FOR SELECT USING (true);

CREATE TABLE IF NOT EXISTS public.attributes (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL,
  values JSONB DEFAULT '[]'::jsonb,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);
ALTER TABLE public.attributes ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Admins manage attributes" ON public.attributes FOR ALL TO authenticated
USING ( public.get_my_role() = 'admin' OR (auth.jwt() ->> 'email') = 'msmraqeeb@gmail.com' )
WITH CHECK ( public.get_my_role() = 'admin' OR (auth.jwt() ->> 'email') = 'msmraqeeb@gmail.com' );
CREATE POLICY "Public read attributes" ON public.attributes FOR SELECT USING (true);

CREATE TABLE IF NOT EXISTS public.coupons (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  code TEXT NOT NULL UNIQUE,
  discount_type TEXT NOT NULL,
  discount_value NUMERIC NOT NULL,
  minimum_spend NUMERIC DEFAULT 0,
  expiry_date DATE NOT NULL,
  status TEXT DEFAULT 'Active',
  auto_apply BOOLEAN DEFAULT false,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);
ALTER TABLE public.coupons ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Admins manage coupons" ON public.coupons FOR ALL TO authenticated
USING ( public.get_my_role() = 'admin' OR (auth.jwt() ->> 'email') = 'msmraqeeb@gmail.com' )
WITH CHECK ( public.get_my_role() = 'admin' OR (auth.jwt() ->> 'email') = 'msmraqeeb@gmail.com' );
CREATE POLICY "Public read coupons" ON public.coupons FOR SELECT USING (true);

CREATE TABLE IF NOT EXISTS public.reviews (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  product_id BIGINT REFERENCES public.products(id) ON DELETE CASCADE,
  product_name TEXT,
  author_name TEXT,
  rating INT CHECK (rating >= 1 AND rating <= 5),
  comment TEXT,
  reply TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);
ALTER TABLE public.reviews ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Admins manage reviews" ON public.reviews FOR ALL TO authenticated
USING ( public.get_my_role() = 'admin' OR (auth.jwt() ->> 'email') = 'msmraqeeb@gmail.com' )
WITH CHECK ( public.get_my_role() = 'admin' OR (auth.jwt() ->> 'email') = 'msmraqeeb@gmail.com' );
CREATE POLICY "Public read reviews" ON public.reviews FOR SELECT USING (true);
CREATE POLICY "Users can insert reviews" ON public.reviews FOR INSERT WITH CHECK (true);

CREATE TABLE IF NOT EXISTS public.settings (
  key TEXT PRIMARY KEY,
  value JSONB NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);
ALTER TABLE public.settings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Admins manage settings" ON public.settings FOR ALL TO authenticated
USING ( public.get_my_role() = 'admin' OR (auth.jwt() ->> 'email') = 'msmraqeeb@gmail.com' )
WITH CHECK ( public.get_my_role() = 'admin' OR (auth.jwt() ->> 'email') = 'msmraqeeb@gmail.com' );
CREATE POLICY "Public read settings" ON public.settings FOR SELECT USING (true);

CREATE TABLE IF NOT EXISTS public.banners (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  type TEXT NOT NULL,
  image_url TEXT NOT NULL,
  title TEXT,
  subtitle TEXT,
  link TEXT,
  sort_order INT DEFAULT 0,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);
ALTER TABLE public.banners ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Admins manage banners" ON public.banners FOR ALL TO authenticated
USING ( public.get_my_role() = 'admin' OR (auth.jwt() ->> 'email') = 'msmraqeeb@gmail.com' )
WITH CHECK ( public.get_my_role() = 'admin' OR (auth.jwt() ->> 'email') = 'msmraqeeb@gmail.com' );
CREATE POLICY "Public read banners" ON public.banners FOR SELECT USING (true);

CREATE POLICY "Users manage own profile" ON public.profiles FOR ALL USING (auth.uid() = id);
CREATE POLICY "Admins view all profiles" ON public.profiles FOR SELECT USING ( public.get_my_role() = 'admin' OR (auth.jwt() ->> 'email') = 'msmraqeeb@gmail.com' );

UPDATE public.profiles SET role = 'admin' WHERE email = 'msmraqeeb@gmail.com';

DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, role)
  VALUES (
    NEW.id,
    NEW.email,
    COALESCE(NEW.raw_user_meta_data->>'full_name', ''),
    CASE WHEN NEW.email = 'msmraqeeb@gmail.com' THEN 'admin' ELSE 'customer' END
  )
  ON CONFLICT (id) DO UPDATE SET role = EXCLUDED.role;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();
